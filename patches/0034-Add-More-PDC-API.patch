From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: LemonCaramel <admin@caramel.moe>
Date: Thu, 20 Jul 2023 04:32:28 +0900
Subject: [PATCH] Add More PDC API


diff --git a/src/main/java/org/bukkit/persistence/PersistentDataContainer.java b/src/main/java/org/bukkit/persistence/PersistentDataContainer.java
index 57609b7793122e135fa0c3b926500849379637b2..d737bc5a220c4738a9f60ab25f17a371dbef219c 100644
--- a/src/main/java/org/bukkit/persistence/PersistentDataContainer.java
+++ b/src/main/java/org/bukkit/persistence/PersistentDataContainer.java
@@ -198,4 +198,148 @@ public interface PersistentDataContainer {
         this.readFromBytes(bytes, true);
     }
     // Paper end
+
+    // Daydream start - Add More PDC API
+    /**
+     * Stores a metadata value on the {@link PersistentDataHolder} instance.
+     * <p>
+     * This API cannot be used to manipulate minecraft data, as the values will
+     * be stored using your namespace. This method will override any existing
+     * value the {@link PersistentDataHolder} may have stored under the provided
+     * key.
+     *
+     * @param key the key this value will be stored under
+     * @param type the type this tag uses
+     * @param value the value stored in the tag
+     * @param <T> the generic java type of the tag value
+     * @param <Z> the generic type of the object to store
+     *
+     * @throws NullPointerException if the key is null
+     * @throws NullPointerException if the type is null
+     * @throws NullPointerException if the value is null. Removing a tag should
+     * be done using {@link #remove(NamespacedKey)}
+     * @throws IllegalArgumentException if no suitable adapter will be found for
+     * the {@link PersistentDataType#getPrimitiveType()}
+     */
+    <T, Z> void set(@NotNull String key, @NotNull PersistentDataType<T, Z> type, @NotNull Z value);
+
+    /**
+     * Returns if the persistent metadata provider has metadata registered
+     * matching the provided parameters.
+     * <p>
+     * This method will only return if the found value has the same primitive
+     * data type as the provided key.
+     * <p>
+     * Storing a value using a custom {@link PersistentDataType} implementation
+     * will not store the complex data type. Therefore storing a UUID (by
+     * storing a byte[]) will match has("key" ,
+     * {@link PersistentDataType#BYTE_ARRAY}). Likewise a stored byte[] will
+     * always match your UUID {@link PersistentDataType} even if it is not 16
+     * bytes long.
+     * <p>
+     * This method is only usable for custom object keys. Overwriting existing
+     * tags, like the the display name, will not work as the values are stored
+     * using your namespace.
+     *
+     * @param key the key the value is stored under
+     * @param type the type which primitive storage type has to match the value
+     * @param <T> the generic type of the stored primitive
+     * @param <Z> the generic type of the eventually created complex object
+     *
+     * @return if a value
+     *
+     * @throws NullPointerException if the key to look up is null
+     * @throws NullPointerException if the type to cast the found object to is
+     * null
+     */
+    <T, Z> boolean has(@NotNull String key, @NotNull PersistentDataType<T, Z> type);
+
+    /**
+     * Returns the metadata value that is stored on the
+     * {@link PersistentDataHolder} instance.
+     *
+     * @param key the key to look up in the custom tag map
+     * @param type the type the value must have and will be casted to
+     * @param <T> the generic type of the stored primitive
+     * @param <Z> the generic type of the eventually created complex object
+     *
+     * @return the value or {@code null} if no value was mapped under the given
+     * value
+     *
+     * @throws NullPointerException if the key to look up is null
+     * @throws NullPointerException if the type to cast the found object to is
+     * null
+     * @throws IllegalArgumentException if the value exists under the given key,
+     * but cannot be access using the given type
+     * @throws IllegalArgumentException if no suitable adapter will be found for
+     * the {@link
+     * PersistentDataType#getPrimitiveType()}
+     */
+    @Nullable
+    <T, Z> Z get(@NotNull String key, @NotNull PersistentDataType<T, Z> type);
+
+    /**
+     * Returns the metadata value that is stored on the
+     * {@link PersistentDataHolder} instance. If the value does not exist in the
+     * container, the default value provided is returned.
+     *
+     * @param key the key to look up in the custom tag map
+     * @param type the type the value must have and will be casted to
+     * @param defaultValue the default value to return if no value was found for
+     * the provided key
+     * @param <T> the generic type of the stored primitive
+     * @param <Z> the generic type of the eventually created complex object
+     *
+     * @return the value or the default value if no value was mapped under the
+     * given value
+     *
+     * @throws NullPointerException if the key to look up is null
+     * @throws NullPointerException if the type to cast the found object to is
+     * null
+     * @throws IllegalArgumentException if the value exists under the given key,
+     * but cannot be access using the given type
+     * @throws IllegalArgumentException if no suitable adapter will be found for
+     * the {@link PersistentDataType#getPrimitiveType()}
+     */
+    @NotNull
+    <T, Z> Z getOrDefault(@NotNull String key, @NotNull PersistentDataType<T, Z> type, @NotNull Z defaultValue);
+
+    /**
+     * Get a set of keys present on this {@link PersistentDataContainer}
+     * instance.
+     *
+     * Any changes made to the returned set will not be reflected on the
+     * instance.
+     *
+     * @return the key set
+     */
+    @NotNull
+    Set<String> keys();
+
+    /**
+     * Removes a custom key from the {@link PersistentDataHolder} instance.
+     *
+     * @param key the key
+     *
+     * @throws NullPointerException if the provided key is null
+     */
+    void remove(@NotNull String key);
+
+    /**
+     * Returns if the persistent metadata provider has metadata registered
+     * matching the provided key.
+     *
+     * @param key the key for which existence should be checked.
+     *
+     * @return whether the key exists
+     *
+     * @throws NullPointerException if the key to look up is null
+     */
+    boolean has(@NotNull String key);
+
+    /**
+     * Clears PersistentDataContainer instances.
+     */
+    void clear();
+    // Daydream end - Add More PDC API
 }
diff --git a/src/main/java/org/bukkit/persistence/PersistentDataHolder.java b/src/main/java/org/bukkit/persistence/PersistentDataHolder.java
index 80b277cc57f092f04fbf7810ac78d250b207b775..43eee3b1ad70189679140a30863d050a8dd84331 100644
--- a/src/main/java/org/bukkit/persistence/PersistentDataHolder.java
+++ b/src/main/java/org/bukkit/persistence/PersistentDataHolder.java
@@ -20,4 +20,19 @@ public interface PersistentDataHolder {
     @NotNull
     PersistentDataContainer getPersistentDataContainer();
 
+    // Daydream start - Add More PDC API
+    /**
+     * Returns a custom tag container capable of storing tags on the object.
+     *
+     * Note that the tags stored on this container are all stored under their
+     * own custom namespace therefore modifying default tags using this
+     * {@link PersistentDataHolder} is impossible.
+     *
+     * @return the persistent metadata container
+     */
+    @NotNull
+    default PersistentDataContainer getPdc() {
+        return getPersistentDataContainer();
+    }
+    // Daydream end - Add More PDC API
 }
